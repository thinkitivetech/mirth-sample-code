<channel version="3.9.1">
  <id>183b6833-a563-42cb-8d4d-cdcb740aef30</id>
  <nextMetaDataId>9</nextMetaDataId>
  <name>AthenaHealth - Bot Receiver - 8581</name>
  <description></description>
  <revision>2</revision>
  <sourceConnector version="3.9.1">
    <metaDataId>0</metaDataId>
    <name>sourceConnector</name>
    <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="3.9.1">
      <pluginProperties>
        <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.9.1">
  <authType>NONE</authType>
        </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
      </pluginProperties>
      <listenerConnectorProperties version="3.9.1">
        <host>0.0.0.0</host>
        <port>8581</port>
      </listenerConnectorProperties>
      <sourceConnectorProperties version="3.9.1">
        <responseVariable>Postprocessor</responseVariable>
        <respondAfterProcessing>true</respondAfterProcessing>
        <processBatch>false</processBatch>
        <firstResponse>false</firstResponse>
        <processingThreads>1</processingThreads>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
        <queueBufferSize>1000</queueBufferSize>
      </sourceConnectorProperties>
      <xmlBody>false</xmlBody>
      <parseMultipart>true</parseMultipart>
      <includeMetadata>false</includeMetadata>
      <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
      <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
      <responseContentType>${http-content-type}</responseContentType>
      <responseDataTypeBinary>false</responseDataTypeBinary>
      <responseStatusCode>${http-status-code}</responseStatusCode>
      <responseHeaders class="linked-hash-map"/>
      <responseHeadersVariable></responseHeadersVariable>
      <useResponseHeadersVariable>false</useResponseHeadersVariable>
      <charset>UTF-8</charset>
      <contextPath></contextPath>
      <timeout>30000</timeout>
      <staticResources/>
    </properties>
    <transformer version="3.9.1">
      <elements>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="3.9.1">
          <sequenceNumber>0</sequenceNumber>
          <enabled>true</enabled>
          <script>var contextPath = sourceMap.get(&apos;contextPath&apos;); 
var method = sourceMap.get(&apos;method&apos;);
var uri = sourceMap.get(&apos;uri&apos;);

var destinationID;

if (method == &apos;GET&apos;) {
	switch(String(contextPath)) {
		case &apos;/athena/sso&apos;:
			destinationID = 2;
			break;
		case &apos;/integration/aws/healthcheck&apos;:
			destinationID = 5;
			break;&#xd;		case &apos;/&apos;:
			destinationID = 9;
			break;
	}
} else if (method == &apos;POST&apos;) {
	if (uri == &apos;/docsink/events&apos;) {
		if (connectorMessage.getRawData() == &apos;&apos;) {
			channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);
		} else {
			var eventData = JSON.parse(connectorMessage.getRawData());
			switch(String(eventData.event_name)) {
				case &apos;bot-installation&apos;:
					destinationID = 1;
					break;
				case &apos;bot-uninstallation&apos;:
					destinationID = 0;
					break;
       		     case &apos;patient-update&apos;:
					destinationID = 3;
					break;
			     // case &apos;appointment-update&apos;:
			     case &apos;appointment_confirmed&apos;:
					destinationID = 4;
					break;
				case &apos;survey_completed&apos;:
					destinationID = 6;
					break;
			}
		}
	}else{
		switch(String(contextPath)) {
		case &apos;/athena/patient/search&apos;:
			destinationID = 7;
			break;&#xd;		case &apos;/athena/patient/save&apos;:
			destinationID = 8;
			break;
		}
		}
}

if (!destinationID) {
	destinationSet.removeAll();
	return;
}

destinationSet.removeAllExcept(destinationID);</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
      </elements>
      <inboundTemplate encoding="base64"></inboundTemplate>
      <outboundTemplate encoding="base64"></outboundTemplate>
      <inboundDataType>RAW</inboundDataType>
      <outboundDataType>RAW</outboundDataType>
      <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
        <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
          <splitType>JavaScript</splitType>
          <batchScript></batchScript>
        </batchProperties>
      </inboundProperties>
      <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
        <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
          <splitType>JavaScript</splitType>
          <batchScript></batchScript>
        </batchProperties>
      </outboundProperties>
    </transformer>
    <filter version="3.9.1">
      <elements/>
    </filter>
    <transportName>HTTP Listener</transportName>
    <mode>SOURCE</mode>
    <enabled>true</enabled>
    <waitForPrevious>true</waitForPrevious>
  </sourceConnector>
  <destinationConnectors>
    <connector version="3.9.1">
      <metaDataId>1</metaDataId>
      <name>Event - installation</name>
      <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.9.1">
        <pluginProperties/>
        <destinationConnectorProperties version="3.9.1">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <script>channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);

var channelBotsDB = globalMap.get(&apos;channel_bots_db&apos;);
var channelApiIntegration = globalMap.get(&apos;channel_client_api_integration&apos;);

var eventData = JSON.parse(connectorMessage.getRawData());
var orgUUID = eventData.org_uuid.toString();
var orgName = eventData.payload.org_name;
var botToken = eventData.payload.token;
var installedByName = eventData.payload.installed_by.first_name + &apos; &apos; + eventData.payload.installed_by.last_name;

var baseMap = Maps.map()
			.add(&apos;org_uuid&apos;, orgUUID)
			.add(&apos;sourceChannelId&apos;, channelId)
			.add(&apos;sourceChannelName&apos;, channelName)
			.add(&apos;sourceMessageId&apos;, connectorMessage.getMessageId().toString());

var orgQueryString = &apos;\
	select \
		id as id \
	from athena_v2.my_ehr_organization \
	where \
		org_uuid = ?;&apos;.replace(/\t/g, &apos;&apos;);
		
var orgQuery = JSON.stringify({
	query: orgQueryString,
	params: [parseInt(orgUUID)]
});
var orgQueryRequest = new RawMessage(orgQuery, [1], baseMap);
var orgQueryResponse = router.routeMessageByChannelId(channelBotsDB, orgQueryRequest);
if (orgQueryResponse.getStatus() != &apos;SENT&apos;) {
	return orgQueryResponse;
}

var orgData = JSON.parse(orgQueryResponse.getMessage());

if (orgData.length &gt; 1) {
	return ResponseFactory.getErrorResponse(&apos;multiple my_ehr organizations found&apos;);
}

var messageString = &apos;&apos;;
if (orgData.length == 0) {
	var insertQuery = JSON.stringify({
		query: &apos;insert into athena_v2.my_ehr_organization(org_uuid, name, org_api_token, installed_by_name) values(?, ? , ?, ?);&apos;,
		params: [parseInt(orgUUID), orgName, botToken, installedByName]
	});
	var insertRequest = new RawMessage(insertQuery, [2], baseMap);
	var insertResponse = router.routeMessageByChannelId(channelBotsDB, insertRequest);
	if (insertResponse.getStatus() != &apos;SENT&apos;) {
		return insertResponse;
	}

	messageString = &apos;Hi &apos; + eventData.payload.installed_by.first_name + &apos;, thanks for adding me to your organization! \
				I\&apos;m here to help integrate data between AthenaHealth and my_ehr. \
				While my chat interactions are limited, I\&apos;m a pro at moving data and keeping you in the loop when something of interest happens. \
				Before I can get to work, we need to link your my_ehr account to the AthenaHealth tablespace that will be used for the integration. \
				I\&apos;ve pinged a fellow my_ehr integration specialist and they will be in touch with you shortly. \
				Feel free to additionally email integrations@my_ehr.com if you have any questions or need further assistance.&apos;.replace(/\t/g, &apos;&apos;);
} else if (orgData.length == 1) {
	var updateQuery = JSON.stringify({
		query: &apos;update athena_v2.my_ehr_organization set name = ?, org_api_token = ?, installed_by_name = ? where org_uuid = ?;&apos;,
		params: [orgName, botToken, installedByName, parseInt(orgUUID)]
	});
	var updateRequest = new RawMessage(updateQuery, [2], baseMap);
	var updateResponse = router.routeMessageByChannelId(channelBotsDB, updateRequest);
	if (updateResponse.getStatus() != &apos;SENT&apos;) {
		return updateResponse;
	}

	messageString = &apos;Welcome back &apos; + eventData.payload.installed_by.first_name + &apos;! \
				I\&apos;ve re-enabled your integration with AthenaHealth using your previous configuration. \
				Please feel free to reach out to the team at integrations@my_ehr.com if you have any question or need further assistance&apos;.replace(/\t/g, &apos;&apos;);
}

messageString = &apos;Hi &apos; + eventData.payload.installed_by.first_name + &apos;, thanks for adding me to your organization! \
				I\&apos;m here to help integrate data between AthenaHealth and my_ehr. \
				While my chat interactions are limited, I\&apos;m a pro at moving data and keeping you in the loop when something of interest happens. \
				Before I can get to work, we need to link your my_ehr account to the AthenaHealth tablespace that will be used for the integration. \
				I\&apos;ve pinged a fellow my_ehr integration specialist and they will be in touch with you shortly. \
				Feel free to additionally email integrations@my_ehr.com if you have any questions or need further assistance.&apos;.replace(/\t/g, &apos;&apos;);

var directMessageData = {
	recipient_uuid: eventData.payload.installed_by.uuid,
	content: messageString
};

var directMessageMap = Maps.map(baseMap).add(&apos;bot_token&apos;, botToken).add(&apos;org_uuid&apos;, orgUUID);
var directMessage = new RawMessage(JSON.stringify(directMessageData), [4], directMessageMap);
var directMessageResult = router.routeMessageByChannelId(channelApiIntegration, directMessage);
if (directMessageResult != &apos;SENT&apos;) {
	return ResponseFactory.getErrorResponse(directMessageResult.getMessage());
}

channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);
return ResponseFactory.getSentResponse(&apos;successfully installed&apos;);</script>
      </properties>
      <transformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.9.1">
        <elements/>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
    <connector version="3.9.1">
      <metaDataId>2</metaDataId>
      <name>SSO - Retrieve DocsInk patient uuid</name>
      <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.9.1">
        <pluginProperties/>
        <destinationConnectorProperties version="3.9.1">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <script>var practiceID = sourceMap.get(&apos;parameters&apos;).getParameter(&apos;practice_id&apos;).toString();
var patientID = sourceMap.get(&apos;parameters&apos;).getParameter(&apos;patient_id&apos;).toString();
var departmentID = sourceMap.get(&apos;parameters&apos;).getParameter(&apos;department_id&apos;);
var email = sourceMap.get(&apos;parameters&apos;).getParameter(&apos;email&apos;);
var username = sourceMap.get(&apos;parameters&apos;).getParameter(&apos;username&apos;);
var orgID = sourceMap.get(&apos;parameters&apos;).getParameter(&apos;org_id&apos;).toString();
var orgUUID = optimus_encode(&apos;dev&apos;, orgID).toString();

var channelAthenaDB = globalMap.get(&apos;channel_athenahealth_db_integration&apos;);
var channelDocsinkAPI = globalMap.get(&apos;channel_client_api_integration&apos;);
var channelAthenaAPI = globalMap.get(&apos;channel_athena_integration&apos;);
var channelBotsDB = globalMap.get(&apos;channel_bots_db&apos;);

if (patientID == &apos;undefined&apos;) {
	patientID = 0;
}

var baseMap = Maps.map()
	.add(&apos;sourceChannelId&apos;, channelId)
	.add(&apos;sourceChannelName&apos;, channelName)
	.add(&apos;sourceMessageId&apos;, connectorMessage.getMessageId().toString())
	.add(&apos;practice_id&apos;, practiceID);

var ssoUserQuery = JSON.stringify({ query: &apos;select * from athena_v2.sso_athena_user(?::bigint, ?::bigint, ?, ?, ?::integer);&apos;, params: [departmentID, patientID, email, username, practiceID] });
var ssoUserRequest = new RawMessage(ssoUserQuery, [1], baseMap);
var ssoUserResponse = router.routeMessageByChannelId(channelBotsDB, ssoUserRequest);
if (ssoUserResponse.getStatus() != &apos;SENT&apos;) {
	return ssoUserResponse;
}

var ssoData = JSON.parse(ssoUserResponse.getMessage());
if (ssoData.length == 0) {
	return ResponseFactory.getErrorResponse(&apos;Athena user not found&apos;);
}

var syncMap= Maps.map(baseMap)
			.add(&apos;patient_id&apos;,patientID)
			.add(&apos;department_id&apos;,departmentID);
			

var channelAthenaAsyncHelpers = globalMap.get(&apos;channel_athena_async_helpers&apos;);
sendMessageToChannelDestination(channelAthenaAsyncHelpers, 1, syncMap, connectorMessage.getRawData());
sendMessageToChannelDestination(channelAthenaAsyncHelpers, 2, syncMap, connectorMessage.getRawData());
sendMessageToChannelDestination(channelAthenaAsyncHelpers, 3, syncMap, connectorMessage.getRawData());
sendMessageToChannelDestination(channelAthenaAsyncHelpers, 5, syncMap, connectorMessage.getRawData());


if (patientID == 0 || ssoData[0].docsink_patient_uuid) {
	channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);
	return ResponseFactory.getSentResponse(JSON.stringify({
		patient_uuid: ssoData[0].docsink_patient_uuid,
		location_uuid: ssoData[0].docsink_location_uuid,
		email: ssoData[0].alternate_email?ssoData[0].alternate_email:ssoData[0].email,
		orgID: optimus_decode(&apos;dev&apos;, ssoData[0].org_uuid).toString()
	}));
}


if (orgUUID != ssoData[0].org_uuid.toString()) {
	orgUUID = ssoData[0].org_uuid.toString();
}

/**
* Get Athena patient from Athena API
*/
var athenaPatientRequestMap = Maps.map(baseMap);
athenaPatientRequestMap.add(&apos;patient_id&apos;, patientID);
var athenaPatientRequest = new RawMessage(&apos;&apos;, [3], athenaPatientRequestMap);
var athenaPatientResponse = router.routeMessageByChannelId(channelAthenaAPI, athenaPatientRequest);
if (athenaPatientResponse.getStatus() != &apos;SENT&apos;) {
	return ResponseFactory.getErrorResponse(athenaPatientResponse.getMessage());
}

var athenaPatient = JSON.parse(athenaPatientResponse.getMessage());

/**
* Upsert Athena patient to DB
*/
var upsertAthenaPatientRequest = new RawMessage(JSON.stringify([athenaPatient]), [1], baseMap);
var upsertAthenaPatientResponse = router.routeMessageByChannelId(channelAthenaDB, upsertAthenaPatientRequest);
if (upsertAthenaPatientResponse.getStatus() != &apos;SENT&apos;) {
	return ResponseFactory.getErrorResponse(upsertAthenaPatientResponse.getMessage());
}

/**
* Retrieve API model mapping
*/
var getPatientApiMappingMap = Maps.map(baseMap);
getPatientApiMappingMap.add(&apos;patient_id&apos;, patientID);
getPatientApiMappingMap.add(&apos;org_uuid&apos;, orgUUID);
var getPatientApiMappingRequest = new RawMessage(&apos;&apos;, [14], baseMap);
var getPatientApiMappingResponse = router.routeMessageByChannelId(channelAthenaDB, getPatientApiMappingRequest);
if (getPatientApiMappingResponse.getStatus() != &apos;SENT&apos;) {
	return ResponseFactory.getErrorResponse(getPatientApiMappingResponse.getMessage());
}

var apiPatient = JSON.parse(getPatientApiMappingResponse.getMessage())[0];


var docsinkPatient;

var upsertPatientMap = Maps.map(baseMap);
upsertPatientMap.add(&apos;resource_type&apos;, &apos;patient&apos;);
upsertPatientMap.add(&apos;bot_token&apos;, ssoData[0].bot_token);
if (apiPatient.docsink_patient_uuid) {
	upsertPatientMap.add(&apos;resource_uuid&apos;, apiPatient.docsink_patient_uuid.toString());
} else {
	var lookupPatientMap = Maps.map();
	lookupPatientMap.clear();
	lookupPatientMap.putAll(baseMap);
	lookupPatientMap.add(&apos;bot_token&apos;, ssoData[0].bot_token).add(&apos;email&apos;, apiPatient.payload.email);
	var lookupPatientMessage = new RawMessage(&apos;&apos;, [7], lookupPatientMap);
	var lookupPatientResult = router.routeMessageByChannelId(channelDocsinkAPI, lookupPatientMessage);
	if (lookupPatientResult.getStatus() != &apos;SENT&apos;) {
		return ResponseFactory.getErrorResponse(lookupPatientResult.getMessage());
	}
	docsinkPatient = JSON.parse(lookupPatientResult.getMessage());
	if (docsinkPatient.uuid) {
		upsertPatientMap.add(&apos;resource_uuid&apos;, docsinkPatient.uuid.toString());
	}
}

var upsertPatientRequest = new RawMessage(JSON.stringify(apiPatient.payload), [1], upsertPatientMap);
var upsertPatientResponse = router.routeMessageByChannelId(channelDocsinkAPI, upsertPatientRequest);

if (upsertPatientResponse.getStatus() != &apos;SENT&apos;) {
	logger.error(channelName + &apos; (&apos; + connectorMessage.getMessageId().toString() + &apos;: failed to upsert patient id &apos; + apiPatient.athena_patient_id.toString());
	logger.debug(channelName + &apos;: &apos; + upsertPatientResponse.getMessage());

	var errorResponse = JSON.parse(upsertPatientResponse.getMessage());
	if (errorResponse.message = &apos;The given data was invalid&apos;) {
		var updatePatientInvalidQuery = JSON.stringify({
			query: &apos;update athena_v2.athena_patient set sync_docsink_invalid_data = true where athena_practice_id = ?::uuid and patient_id = ?::bigint;&apos;,
			params: [orgPracticeMappings[0].pk_athena_practice_id.toString(), docsinkApiPatient.athena_patient_id.toString()]
		});
		var updatePatientInvalidRequest = new RawMessage(updatePatientInvalidQuery, [2], baseMap);
		var updatePatientInvalidResponse = router.routeMessageByChannelId(channelBotsDB, updatePatientInvalidRequest);
		if (updatePatientInvalidResponse.getStatus() != &apos;SENT&apos;) {
			logger.error(channelName + &apos; (&apos; + connectorMessage.getMessageId().toString() + &apos;: failed to upsert invalid data flag for patient id &apos; + docsinkApiPatient.athena_patient_id.toString());
			logger.debug(channelName + &apos;: &apos; + updatePatientInvalidResponse.getMessage());
		}
	}

	return ResponseFactory.getErrorResponse(errorResponse);
}

var docsinkPatient = upsertPatientResponse.getMessage();

var upsertPatientMappingQuery = JSON.stringify({
	query: &apos;select athena_v2.docsink_upsert_patient_with_athena_mapping(?::bigint, ?::jsonb, ?::bigint, ?::bigint);&apos;,
	params: [orgUUID, docsinkPatient, practiceID, patientID]
});
var upsertPatientMappingRequest = new RawMessage(upsertPatientMappingQuery, [1], baseMap);
var upsertPatientMappingResponse = router.routeMessageByChannelId(channelBotsDB, upsertPatientMappingRequest);
if (upsertPatientMappingResponse.getStatus() != &apos;SENT&apos;) {
	logger.error(channelName + &apos; (&apos; + connectorMessage.getMessageId().toString() + &apos;: failed to upsert mapping for patient id &apos; + patientID.toString());
	logger.debug(channelName + &apos;: &apos; + upsertPatientMappingResponse.getMessage());
	return ResponseFactory.getErrorResponse(upsertPatientMappingResponse.getMessage());
}

docsinkPatient = JSON.parse(docsinkPatient);


channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);
return ResponseFactory.getSentResponse(JSON.stringify({
	patient_uuid: docsinkPatient.uuid,
	location_uuid: ssoData[0].docsink_location_uuid,
	email:ssoData[0].alternate_email?ssoData[0].alternate_email:ssoData[0].email,
	orgID: optimus_decode(&apos;dev&apos;, ssoData[0].org_uuid).toString()
}));</script>
      </properties>
      <transformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.9.1">
        <elements/>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>false</waitForPrevious>
    </connector>
    <connector version="3.9.1">
      <metaDataId>3</metaDataId>
      <name>Push Docsink patient demographic upserts to AthenaHealth </name>
      <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.9.1">
        <pluginProperties/>
        <destinationConnectorProperties version="3.9.1">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <script>
var messageData = JSON.parse(connectorMessage.getEncodedData());
var payload = messageData.payload;
var patientID = messageData.payload.uuid;

var orgID = messageData.org_uuid.toString();
var channelAthenaDB = globalMap.get(&apos;channel_athenahealth_db_integration&apos;);
var channelAthenaAPI = globalMap.get(&apos;channel_athena_integration&apos;);
var channelBotsDB = globalMap.get(&apos;channel_bots_db&apos;);

var baseMap = Maps.map()
				.add(&apos;org_uuid&apos;, orgID)
				.add(&apos;sourceChannelId&apos;, channelId)
				.add(&apos;sourceChannelName&apos;, channelName)
				.add(&apos;sourceMessageId&apos;, connectorMessage.getMessageId().toString());

/**
* Upsert docsink patient to DB
*/

var upsertdocsinkPatientRequest = new RawMessage(JSON.stringify([payload]), [17], baseMap);
var upsertdocsinkPatientResponse = router.routeMessageByChannelId(channelAthenaDB, upsertdocsinkPatientRequest);
if (upsertdocsinkPatientResponse.getStatus() != &apos;SENT&apos;) {
	return ResponseFactory.getErrorResponse(upsertdocsinkPatientResponse.getMessage());
}

var docsinkPatient = JSON.parse(upsertdocsinkPatientResponse.getMessage());
/*

/**
* Upsert get Athena patient id and practice id details by using docsink uuid to DB 


var getPatientApiMappingMap = Maps.map(baseMap);
getPatientApiMappingMap.add(&apos;patient_id&apos;, patientID);
var getPatientApiMappingRequest = new RawMessage(JSON.stringify([payload]), [18], baseMap);
var getPatientApiMappingResponse = router.routeMessageByChannelId(channelAthenaDB, getPatientApiMappingRequest);
if (getPatientApiMappingResponse.getStatus() != &apos;SENT&apos;) {
	return ResponseFactory.getErrorResponse(getPatientApiMappingResponse.getMessage());
}

var apiPatient = JSON.parse(getPatientApiMappingResponse.getMessage())[0];

var athenaPatient;

var upsertPatientMap = Maps.map(baseMap);

if (apiPatient.athena_patient_id) {
	upsertPatientMap.add(&apos;athena_patient_id&apos;, apiPatient.athena_patient_id.toString());
	upsertPatientMap.add(&apos;practice_id&apos;, apiPatient.athena_practice_id.toString());
} else {
	return ResponseFactory.getErrorResponse({&quot;message&quot;:&quot;No mappings found in db.&quot;});
}

var upsertPatientRequest = new RawMessage(JSON.stringify(apiPatient.payload), [17], upsertPatientMap);
var upsertPatientResponse = router.routeMessageByChannelId(channelAthenaAPI, upsertPatientRequest);

if (upsertPatientResponse.getStatus() != &apos;SENT&apos;) {
	return upsertPatientResponse;
}

var athenaPatient = JSON.parse(upsertPatientResponse.getMessage());

var upsertPatientMappingQuery = JSON.stringify({
	query: &apos;select athena_v2.docsink_upsert_patient_with_athena_mapping(?::bigint, ?::jsonb, ?::bigint, ?::bigint);&apos;,
	params: [orgID, JSON.stringify([payload]), apiPatient.athena_practice_id.toString(), athenaPatient[0].patientid]
});
var upsertPatientMappingRequest = new RawMessage(upsertPatientMappingQuery, [1], baseMap);
var upsertPatientMappingResponse = router.routeMessageByChannelId(channelBotsDB, upsertPatientMappingRequest);
if (upsertPatientMappingResponse.getStatus() != &apos;SENT&apos;) {
	logger.error(channelName + &apos; (&apos; + connectorMessage.getMessageId().toString() + &apos;: failed to upsert mapping for patient id &apos; + patientID.toString());
	logger.debug(channelName + &apos;: &apos; + upsertPatientMappingResponse.getMessage());
	return ResponseFactory.getErrorResponse(upsertPatientMappingResponse.getMessage());
}

*/
channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);
return ResponseFactory.getSentResponse(JSON.stringify({&apos;message&apos;:&apos;docsink patient updated in database.&apos;}));</script>
      </properties>
      <transformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.9.1">
        <elements/>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>false</waitForPrevious>
    </connector>
    <connector version="3.9.1">
      <metaDataId>4</metaDataId>
      <name>Send appointment confirmations to AthenaHealth</name>
      <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.9.1">
        <pluginProperties/>
        <destinationConnectorProperties version="3.9.1">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <script>
var messageData = JSON.parse(connectorMessage.getRawData());
var patientData =  JSON.parse(connectorMessage.getEncodedData());
var payload = messageData.payload;
var appointmentID = messageData.payload.uuid;

var orgID = messageData.org_uuid.toString();
var channelAthenaDB = globalMap.get(&apos;channel_athenahealth_db_integration&apos;);
var channelAthenaAPI = globalMap.get(&apos;channel_athena_integration&apos;);
var channelBotsDB = globalMap.get(&apos;channel_bots_db&apos;);

var baseMap = Maps.map()
				.add(&apos;org_uuid&apos;, orgID)
				.add(&apos;sourceChannelId&apos;, channelId)
				.add(&apos;sourceChannelName&apos;, channelName)
				.add(&apos;sourceMessageId&apos;, connectorMessage.getMessageId().toString());

/**
* Upsert docsink appointment to DB
*/

payload.patient = patientData;

var upsertdocsinkAppointmentRequest = new RawMessage(JSON.stringify([payload]), [25], baseMap);
var upsertdocsinkAppointmentResponse = router.routeMessageByChannelId(channelAthenaDB, upsertdocsinkAppointmentRequest);
if (upsertdocsinkAppointmentResponse.getStatus() != &apos;SENT&apos;) {
	return ResponseFactory.getErrorResponse(upsertdocsinkAppointmentResponse.getMessage());
}

channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);
return ResponseFactory.getSentResponse(JSON.stringify({&apos;message&apos;:&apos;docsink appointment updated in database.&apos;}));
//return ResponseFactory.getSentResponse(upsertdocsinkAppointmentResponse.getMessage());</script>
      </properties>
      <transformer version="3.9.1">
        <elements>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="3.9.1">
            <name>Get docsink-access-token by org-uuid</name>
            <sequenceNumber>0</sequenceNumber>
            <enabled>true</enabled>
            <script>var msgData = JSON.parse(connectorMessage.getRawData());
var channelBotsDB = globalMap.get(&apos;channel_bots_db&apos;);
var channelBotIntegration = globalMap.get(&apos;channel_client_api_integration&apos;);
var orgUUID = msgData.org_uuid.toString();
var baseMap = Maps.map()
			.add(&apos;org_uuid&apos;, orgUUID)
			.add(&apos;sourceChannelId&apos;, channelId)
			.add(&apos;sourceChannelName&apos;, channelName)
			.add(&apos;sourceMessageId&apos;, connectorMessage.getMessageId().toString());

var orgQueryString = &apos;\
	select \
		id as id, \
		org_api_token as token \
	from athena_v2.docsink_organization \
	where \
		org_uuid = ?;&apos;.replace(/\t/g, &apos;&apos;);
		
var orgQuery = JSON.stringify({
	query: orgQueryString,
	params: [parseInt(orgUUID)]
});
var orgQueryRequest = new RawMessage(orgQuery, [1], baseMap);
var orgQueryResponse = router.routeMessageByChannelId(channelBotsDB, orgQueryRequest);
if (orgQueryResponse.getStatus() != &apos;SENT&apos;) {
	return orgQueryResponse;
}

 var token = JSON.parse(orgQueryResponse.getMessage())[0].token;</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="3.9.1">
            <sequenceNumber>1</sequenceNumber>
            <enabled>true</enabled>
            <script>var lookupPatientMap = Maps.map(baseMap);
lookupPatientMap.add(&apos;bot_token&apos;, token).add(&apos;patient_uuid&apos;, msgData.payload.patient_uuid.toString());
var lookupPatientMessage = new RawMessage(&apos;&apos;, [9], lookupPatientMap);
var lookupPatientResult = router.routeMessageByChannelId(channelBotIntegration, lookupPatientMessage);
if (lookupPatientResult.getStatus() != &apos;SENT&apos;) {
	return lookupPatientResult.getMessage();
}
msg = JSON.parse(lookupPatientResult.getMessage()).data;</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        </elements>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.9.1">
        <elements/>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>false</waitForPrevious>
    </connector>
    <connector version="3.9.1">
      <metaDataId>5</metaDataId>
      <name>AWS Healthcheck</name>
      <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.9.1">
        <pluginProperties/>
        <destinationConnectorProperties version="3.9.1">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <script>channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);
return ResponseFactory.getSentResponse(JSON.stringify({&apos;message&apos;:&apos;success&apos;}));</script>
      </properties>
      <transformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.9.1">
        <elements/>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>false</waitForPrevious>
    </connector>
    <connector version="3.9.1">
      <metaDataId>6</metaDataId>
      <name>DocsInk event - assessment completed</name>
      <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.9.1">
        <pluginProperties/>
        <destinationConnectorProperties version="3.9.1">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <script>var channelBotsDB = globalMap.get(&apos;channel_bots_db&apos;);
var channelAthenaIntegration = globalMap.get(&apos;channel_athena_integration&apos;);
var channelDocsinkIntegration = globalMap.get(&apos;channel_client_api_integration&apos;);
var botChannel = globalMap.get(&apos;channel_client_api_sender&apos;);

var assessmentEvent = JSON.parse(connectorMessage.getEncodedData());

var queryString = &apos;\
	select \
		org.org_uuid, \
		org.org_api_token, \
		prac.practice_id, \
		pat.uuid, \
		pat.user_uuid, \
		apat.patient_id, \
		adept.department_id \
	from athena_v2.docsink_organization org \
	join athena_v2.athena_practice prac \
		on prac.id = org.athena_practice_id \
	join athena_v2.docsink_patient pat \
		on pat.docsink_organization_id = org.id \
	join athena_v2.mapping_athena_patient_to_docsink_patient mpat \
		on mpat.docsink_patient_id = pat.id \
		and mpat.docsink_organization_id = org.id \
	join athena_v2.athena_patient apat \
		on mpat.athena_patient_id = apat.id \
		and apat.athena_practice_id = prac.id \
	join athena_v2.athena_departments adept \
		on adept.id = apat.athena_primary_department_id \
		and adept.athena_practice_id = prac.id \
	where \
		pat.user_uuid = ? \
		AND org.org_uuid = ?;&apos;.replace(/\t/g, &apos;&apos;);
		
var queryData = JSON.stringify({ query: queryString, params: [ assessmentEvent.payload.recipient_uuid, assessmentEvent.org_uuid ] });

var queryResponseData = JSON.parse(sendMessageToChannelDestination(channelBotsDB, 1, null, queryData));

if (queryResponseData.length == 0) {
	channelMap.put(&apos;http-content-type&apos;, &apos;text/plain&apos;);
	return ResponseFactory.getErrorResponse(&apos;unknown organization&apos;);
}

var token = queryResponseData[0].org_api_token;

var pdfMap = Maps.map()
			.add(&apos;org_uuid&apos;, assessmentEvent.org_uuid.toString())
			.add(&apos;bot_token&apos;, token)
			.add(&apos;assessment_uuid&apos;, assessmentEvent.payload.uuid.toString());

var pdfString = sendMessageToChannelDestination(channelDocsinkIntegration, 19, pdfMap, null);

var uploadDocumentMap = Maps.map()
	.add(&apos;practice_id&apos;, queryResponseData[0].practice_id.toString())
	.add(&apos;patient_id&apos;, queryResponseData[0].patient_id.toString())
	.add(&apos;department_id&apos;, queryResponseData[0].department_id.toString())
	.add(&apos;org_uuid&apos;, assessmentEvent.org_uuid.toString());

return sendMessageToChannelDestination(channelAthenaIntegration, 15, uploadDocumentMap, pdfString);</script>
      </properties>
      <transformer version="3.9.1">
        <elements/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.9.1">
        <elements>
          <com.mirth.connect.plugins.javascriptrule.JavaScriptRule version="3.9.1">
            <sequenceNumber>0</sequenceNumber>
            <enabled>true</enabled>
            <script>var eventData = JSON.parse(msg);
return eventData.payload.completed;</script>
          </com.mirth.connect.plugins.javascriptrule.JavaScriptRule>
        </elements>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>false</waitForPrevious>
    </connector>
    <connector version="3.9.1">
      <metaDataId>7</metaDataId>
      <name>Send patient-search result to docsink</name>
      <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.9.1">
        <pluginProperties/>
        <destinationConnectorProperties version="3.9.1">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <script>channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);
var messageData = JSON.parse(connectorMessage.getRawData());
var orgData = JSON.parse(connectorMessage.getEncodedData())[0];
var payload = messageData;

var orgID = messageData.org_uuid.toString();
var channelAthenaDB = globalMap.get(&apos;channel_athenahealth_db_integration&apos;);
var channelAthenaAPI = globalMap.get(&apos;channel_athena_integration&apos;);

var baseMap = Maps.map()
				.add(&apos;org_uuid&apos;, orgID)
				.add(&apos;sourceChannelId&apos;, channelId)
				.add(&apos;sourceChannelName&apos;, channelName)
				.add(&apos;sourceMessageId&apos;, connectorMessage.getMessageId().toString());

/**
* Send Patient-result to docsink
*/
		var lookupPatientMap = Maps.map();
		lookupPatientMap.putAll(baseMap);
		lookupPatientMap.add(&apos;practice_id&apos;, orgData.practice_id.toString());
		var lookupPatientMessage = new RawMessage(JSON.stringify(payload), [23], lookupPatientMap);
		var lookupPatientResult = router.routeMessageByChannelId(channelAthenaAPI, lookupPatientMessage);
		if (lookupPatientResult.getStatus() != &apos;SENT&apos;) {
			return lookupPatientResult.getMessage();
		}
channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);
		
return ResponseFactory.getSentResponse(&apos;[&apos;+lookupPatientResult.getMessage()+&apos;]&apos;);</script>
      </properties>
      <transformer version="3.9.1">
        <elements>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="3.9.1">
            <name>Get athena practice id details.</name>
            <sequenceNumber>0</sequenceNumber>
            <enabled>true</enabled>
            <script>var messageData = JSON.parse(msg);


var baseMap = Maps.map()
			.add(&apos;sourceChannelId&apos;, channelId)
			.add(&apos;sourceChannelName&apos;, channelName)
			.add(&apos;sourceMessageId&apos;, connectorMessage.getMessageId().toString());
			
var channelBotsDB = globalMap.get(&apos;channel_bots_db&apos;);
var orgUUID  = messageData.org_uuid.toString();


var query = &quot;\
	select \
		o.id, \
		ap.practice_id \
		from athena_v2.docsink_organization o \
		join athena_v2.athena_practice ap \
		on o.athena_practice_id = ap.id \
		where \
		o.org_uuid = ?::bigint;&quot;.replace(/\t/g, &apos;&apos;);
		 
var request = JSON.stringify({
	query: query,
	params: [orgUUID]
});

var rawMessage = new RawMessage(request, [1], baseMap);
var result = router.routeMessageByChannelId(channelBotsDB, rawMessage);
if (result.getStatus() != &apos;SENT&apos;) {
	throw result.getMessage();
}

msg = result.getMessage();</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        </elements>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.9.1">
        <elements/>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
    <connector version="3.9.1">
      <metaDataId>8</metaDataId>
      <name>Save athena-search patient</name>
      <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.9.1">
        <pluginProperties/>
        <destinationConnectorProperties version="3.9.1">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <script>channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);
var messageData = JSON.parse(connectorMessage.getRawData());
var orgData = JSON.parse(connectorMessage.getEncodedData())[0];
var payload = messageData;

var orgID = messageData.org_uuid.toString();
var channelAthenaDB = globalMap.get(&apos;channel_athenahealth_db_integration&apos;);
var channelAthenaAPI = globalMap.get(&apos;channel_athena_integration&apos;);

var baseMap = Maps.map()
				.add(&apos;org_uuid&apos;, orgID)
				.add(&apos;sourceChannelId&apos;, channelId)
				.add(&apos;sourceChannelName&apos;, channelName)
				.add(&apos;sourceMessageId&apos;, connectorMessage.getMessageId().toString())
				.add(&apos;practice_id&apos;, orgData.practice_id.toString());
/**
*  Get patient details by patient id
*/

var lookupPatientMap = Maps.map();
lookupPatientMap.putAll(baseMap);
lookupPatientMap.add(&apos;patient_id&apos;, payload.patientid);;
var lookupPatientMessage = new RawMessage(JSON.stringify(payload), [3], lookupPatientMap);
var lookupPatientResult = router.routeMessageByChannelId(channelAthenaAPI, lookupPatientMessage);
if (lookupPatientResult.getStatus() != &apos;SENT&apos;) {
	return lookupPatientResult.getMessage();
}

var athenaPatient = JSON.parse(lookupPatientResult.getMessage());

/**
* Upsert Athena patient to DB
*/

var upsertAthenaPatientRequest = new RawMessage(JSON.stringify([athenaPatient]), [1], baseMap);
var upsertAthenaPatientResponse = router.routeMessageByChannelId(channelAthenaDB, upsertAthenaPatientRequest);
if (upsertAthenaPatientResponse.getStatus() != &apos;SENT&apos;) {
	return ResponseFactory.getErrorResponse(upsertAthenaPatientResponse.getMessage());
}
channelMap.put(&apos;http-status-code&apos;, &apos;200&apos;);		
return ResponseFactory.getSentResponse(lookupPatientResult.getMessage());</script>
      </properties>
      <transformer version="3.9.1">
        <elements>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="3.9.1">
            <name>Get athena practice id details.</name>
            <sequenceNumber>0</sequenceNumber>
            <enabled>true</enabled>
            <script>var messageData = JSON.parse(msg);


var baseMap = Maps.map()
			.add(&apos;sourceChannelId&apos;, channelId)
			.add(&apos;sourceChannelName&apos;, channelName)
			.add(&apos;sourceMessageId&apos;, connectorMessage.getMessageId().toString());
			
var channelBotsDB = globalMap.get(&apos;channel_bots_db&apos;);
var orgUUID  = messageData.org_uuid.toString();


var query = &quot;\
	select \
		o.id, \
		ap.practice_id \
		from athena_v2.docsink_organization o \
		join athena_v2.athena_practice ap \
		on o.athena_practice_id = ap.id \
		where \
		o.org_uuid = ?::bigint;&quot;.replace(/\t/g, &apos;&apos;);
		 
var request = JSON.stringify({
	query: query,
	params: [orgUUID]
});

var rawMessage = new RawMessage(request, [1], baseMap);
var result = router.routeMessageByChannelId(channelBotsDB, rawMessage);
if (result.getStatus() != &apos;SENT&apos;) {
	throw result.getMessage();
}

msg = result.getMessage();</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        </elements>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.9.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.9.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.9.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.9.1">
        <elements/>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
  </destinationConnectors>
  <preprocessingScript>// Modify the message variable below to pre process data

channelMap.put(&apos;http-status-code&apos;, &apos;500&apos;);

return message;</preprocessingScript>
  <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map

var destinations = sourceMap.get(&apos;destinationSet&apos;);
var metadataIds = destinations.toArray();

if (metadataIds.length == 0) {
	return ResponseFactory.getErrorResponse(&apos;invalid request&apos;);
}

var smsg = message.getConnectorMessages().get(0);
if (smsg.getStatus() == &apos;ERROR&apos;) {
	return smsg;
}

var metadataID = metadataIds[0];
var cmsg = message.getConnectorMessages().get(metadataID);

if (cmsg.getStatus() == &apos;ERROR&apos;) {
	responseMap.put(&apos;http-content-type&apos;, &apos;text/plain&apos;);
	return &apos;Internal Server Error&apos;;
}

return cmsg.getResponseData();</postprocessingScript>
  <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
  <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
  <properties version="3.9.1">
    <clearGlobalChannelMap>true</clearGlobalChannelMap>
    <messageStorageMode>PRODUCTION</messageStorageMode>
    <encryptData>false</encryptData>
    <removeContentOnCompletion>false</removeContentOnCompletion>
    <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
    <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
    <initialState>STARTED</initialState>
    <storeAttachments>true</storeAttachments>
    <metaDataColumns/>
    <attachmentProperties version="3.9.1">
      <type>None</type>
      <properties/>
    </attachmentProperties>
    <resourceIds class="linked-hash-map">
      <entry>
        <string>Default Resource</string>
        <string>[Default Resource]</string>
      </entry>
    </resourceIds>
  </properties>
  <exportData>
    <metadata>
      <enabled>true</enabled>
      <lastModified>
        <time>1637230537143</time>
        <timezone>Asia/Kolkata</timezone>
      </lastModified>
      <pruningSettings>
        <pruneMetaDataDays>30</pruneMetaDataDays>
        <archiveEnabled>true</archiveEnabled>
      </pruningSettings>
    </metadata>
    <codeTemplateLibraries>
      <codeTemplateLibrary version="3.9.1">
        <id>d316c4bc-9e10-4162-b67c-e514afc59fa3</id>
        <name>Channel Helpers</name>
        <revision>1</revision>
        <lastModified>
          <time>1636720334943</time>
          <timezone>Asia/Kolkata</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>1aca2a66-a83a-4703-9ec7-dfaa3a6ad5b2</string>
          <string>3e15b608-553f-45e7-a617-712d6b75ab4d</string>
          <string>2f511815-92d1-4f0f-92e9-f4f8ae576b75</string>
          <string>b4a51816-0aad-444a-b1ce-f5c11f9961bc</string>
          <string>cb7f055d-45ae-43b7-ac7c-bb2b2db34ded</string>
          <string>139cdc6a-5f40-46bd-a246-2a9a1ef8ed10</string>
          <string>6ff8ca2b-c4e3-4e6f-897a-17f36ed63faa</string>
          <string>27aee1c0-8ed0-4062-89b5-1c7a69a946bc</string>
          <string>291b4847-a85d-41c6-bd4a-37f008b15ca8</string>
          <string>81c836fd-cbba-4247-b438-d4c9987ee75b</string>
          <string>0763b542-8ed8-4a30-9c35-de3dbf030626</string>
          <string>75c150e0-fbc5-4eef-a856-bec6b3a39a24</string>
          <string>dd55a671-a099-4b29-bdbb-85c34050037a</string>
          <string>ae504043-55f5-497e-ac87-33686e7569b2</string>
          <string>69f5ad2c-3bf4-4d55-8e4a-bd6faade202d</string>
          <string>a8bd6f50-894f-443f-b248-da3ebad3a748</string>
          <string>1e45f5ac-6815-40a8-8fe9-15e98eb1d07b</string>
          <string>3d95de17-a2ea-446c-be4c-36c32d8cda1c</string>
          <string>fdcb1121-0d49-4ed8-b1a1-4f4482e1c20a</string>
          <string>8c5d3887-bd22-4018-aeda-45e5c0f8d551</string>
          <string>a127fffb-1663-4206-b6d3-348aa228c999</string>
          <string>143b10e0-e01b-4942-9995-2d3b9a165d76</string>
          <string>6060b76d-07c2-4f9f-bc71-d2e8c44d8271</string>
          <string>08536fee-6f99-4cc4-8958-f84daaee73d5</string>
          <string>183b6833-a563-42cb-8d4d-cdcb740aef30</string>
          <string>bd81709b-2ef0-4760-aba9-f455fb338f37</string>
          <string>695c7ed6-252e-4229-83db-5571946a8b62</string>
          <string>50dcf6de-46b4-4de5-99c2-d341abb8a41a</string>
          <string>ed4ef090-3f7e-442d-ad30-744e3a1313f2</string>
          <string>ed3e52dc-3023-4cc7-8cad-47e0d5df89c1</string>
          <string>ec29c308-0bc3-4eb0-a948-09c2c0747afa</string>
          <string>aeaba1c0-cef9-4ad8-82d7-76d66cc95562</string>
          <string>2a33ffd6-253d-402f-8fb6-93bd94f65dcd</string>
          <string>7445aaa5-ff13-4c08-a8b1-817cfed2692b</string>
          <string>dcaf136d-a3b8-47ed-aec7-d1619675ba2d</string>
          <string>90bc60ed-14c6-49db-b1e6-bb70d2b1d01d</string>
          <string>7ee4a47d-bdf3-473d-9da9-3a62c41037b1</string>
          <string>167ee803-661a-4e6e-ac6e-b84c057f7ca1</string>
          <string>a40e7657-c37a-4fb6-aa79-48a2ea16709c</string>
          <string>5d5e5835-8cd3-43af-ac82-ffe57439bfb5</string>
          <string>ae961745-fe19-46bd-b240-c82888091366</string>
          <string>68581957-7fba-421f-b063-941a804fcc46</string>
          <string>0056a8aa-7aa5-4047-a693-21bac64470aa</string>
          <string>2a637fa3-fb83-4666-abe0-c754924ff738</string>
          <string>d448196a-4282-4d10-8c9a-7f1dfd19abea</string>
          <string>05759809-cfbd-4546-8b71-fd28c2499763</string>
          <string>881db416-1776-4ab6-a3ce-5065ed11cdb5</string>
          <string>982b29a5-1743-4435-8842-9810e4e34926</string>
          <string>1bff9775-2de8-4b51-bb6b-6aaa29c144bb</string>
          <string>9316c229-da47-49f8-a2c0-398ba155d370</string>
          <string>55ebb133-1e4d-4172-8718-301240e9518f</string>
          <string>492a7c6c-4768-45e2-9f49-6c5488b0a2e5</string>
          <string>14a2ad40-95bb-4ac9-a10e-d326537cc5a6</string>
          <string>6aa39894-bc9b-448c-aac6-b6967a0ce243</string>
          <string>4108a56a-b1a6-4d8c-9e8e-b065654860d0</string>
          <string>bdb4241f-2858-49da-8d4e-2f1579679620</string>
          <string>692365a7-9ec6-4c38-adee-672f4084adf3</string>
          <string>3f433a3e-e46d-440a-82c1-5490ada6b54e</string>
          <string>72471096-425b-4750-81a4-123fca2e302c</string>
          <string>4a05dc00-9ad6-454a-b61b-ddd074bbb36c</string>
          <string>9d1c136c-3c94-43c3-b0f8-1c1551ac6987</string>
          <string>b2fdd8c2-f387-493b-ab35-e7e9e8ce056a</string>
          <string>930a4c9e-b458-4edf-92ff-3be07d68c28d</string>
          <string>0f0df6c9-1153-4e0b-800b-533492ba936c</string>
          <string>455c536f-d3fb-4832-941e-ef230b683590</string>
          <string>31b37e0b-cfbf-4787-b5d3-2082328fafd7</string>
          <string>21e47d6b-9863-4045-82af-8941087a4da1</string>
          <string>b3869a86-7d4f-4a10-b116-24b758a191b3</string>
          <string>a6825055-e697-487f-9add-560ad9567a60</string>
          <string>f7552865-32a0-4b5b-a5fd-9b0bddffddf9</string>
          <string>9f2bcd3c-8a74-49f1-b910-aa05c509c9cb</string>
          <string>bd270438-7262-47f8-8656-1baf51287078</string>
          <string>61b10ef9-baef-45e2-b747-a0987d851033</string>
          <string>aa5ba1e6-ab11-4a9a-a03c-e0fe58b49086</string>
          <string>ec653b8b-7362-4167-98ff-3845c7560d11</string>
          <string>25c5fbce-cb87-4ba9-a572-0be49242a0b2</string>
          <string>13738349-4cc4-43de-9365-a27ead17b524</string>
          <string>a43f7553-71de-41d3-aa16-93cc7a48bafc</string>
          <string>e1900e14-c2a2-426e-86f0-971353d60cdd</string>
          <string>99066deb-0d43-44f6-8823-b8cfe08e7185</string>
          <string>aa30f2b5-64cf-4396-b098-efeecb2224f2</string>
          <string>9fee4e0a-7a6d-4925-bc78-59df2c1f28af</string>
          <string>57953b24-64cb-489d-9706-bf5dc1ef94ea</string>
          <string>08955a01-dda6-468b-a8cf-73586fe7d99f</string>
          <string>470c6c09-6850-4770-820c-bbfce54196bd</string>
          <string>21a820f0-205a-4046-8c4a-3788daca4d05</string>
          <string>9a44798a-871f-4402-9397-75241b18c6b0</string>
          <string>8b61cf50-9d95-43dd-b6ab-474e2a1d2d76</string>
          <string>4041500f-7768-4011-b273-13fe61a2ebd6</string>
          <string>0e0f63c0-5b51-4626-9a50-c0e2f5f94d37</string>
          <string>f836f593-4c61-49bd-be13-4cb3f9c6cffb</string>
          <string>0fec52ca-be59-47c9-85b1-700dc3b3dc2e</string>
          <string>4d75bdd7-6d1f-4db5-a7f8-4f63efa13197</string>
          <string>53d49d46-bd95-4ce5-8f98-7685217fedbf</string>
          <string>8c637e01-95b0-4b11-a28f-4518b7f8d1ae</string>
          <string>7f5da166-70b8-48e0-9fa9-cf96fd867c30</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="3.9.1">
            <id>bc768cd6-d735-40b1-9617-a3417481fe19</id>
            <name>Convert CSV to JSON</name>
            <revision>1</revision>
            <lastModified>
              <time>1636720335071</time>
              <timezone>Asia/Kolkata</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} csv - CSV string with column headers
	@return {String} return JSON object using column headers and field keys
*/
function convertCsvToJson(csv) {
	var textXML = SerializerFactory.getSerializer(&apos;DELIMITED&apos;).toXML(csv);
	var xml = new XML(textXML);
	var dataItems = [];
	for (var i = 1; i &lt;= xml[&apos;row&apos;].length() - 1; i++) {
		var jsonData = {};
		for (var j = 1; j &lt;= xml[&apos;row&apos;][0].children().length(); j++) {
			var column = &apos;column&apos; + j.toString();
			var header = xml[&apos;row&apos;][0][column].toString().replace(/\s/g, &apos;_&apos;).replace(/-/g, &apos;_&apos;).toLowerCase();
			var value = xml[&apos;row&apos;][i][column].toString();
			
			jsonData[header] = value;
			
		}
		dataItems.push(jsonData);
	}

	return JSON.stringify(dataItems);
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>ff3df0b8-cfa2-4ec9-82ac-37c9e4830e0c</id>
            <name>Generic - Send message to channel destination</name>
            <revision>1</revision>
            <lastModified>
              <time>1636720335173</time>
              <timezone>Asia/Kolkata</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function sendMessageToChannelDestination(channelID, destinationID, map, data) {
	var msgMap;
	var outData = {};
	
	if (!map) {
		msgMap = Maps.map();
	} else {
		msgMap = Maps.map(map);
	}

	if (data == null || data == undefined) {
		data = &apos;&apos;;
	}

	if (msgMap.get(&apos;sourceChannelId&apos;) == null) {
		msgMap.add(&apos;sourceChannelId&apos;, channelId);
	}
	if (msgMap.get(&apos;sourceChannelName&apos;) == null) {
		msgMap.add(&apos;sourceChannelName&apos;, channelName);
	}

	// Dirty way to handle connector message not being defined. Handles cases where this function 
	// is used in a source js writer.
	try {
		if (msgMap.get(&apos;sourceMessageId&apos;) == null &amp;&amp; connectorMessage &amp;&amp; connectorMessage.getMessageId()) {
			msgMap.add(&apos;sourceMessageId&apos;, connectorMessage.getMessageId().toString());
		}
	} catch(ex) {}

	var msgRequest = new RawMessage(data, [destinationID], msgMap);
	var msgResponse = router.routeMessageByChannelId(channelID, msgRequest);

	if (msgResponse == null) {
		// return;
		throw ChannelUtil.getChannelName(channelID) + &apos;&quot; does not return a valid response object&apos;; 
	}
	if (msgResponse.getStatus() == null) {
		throw ChannelUtil.getChannelName(channelID) + &apos;&quot; does not return a valid response object&apos;;
	}

	if (msgResponse.getStatus() == &apos;ERROR&apos;) {
		throw msgResponse.getMessage();
	}

	return msgResponse.getMessage();
	
	
	// var msgResponse;

	/*
	try {
		msgResponse = router.routeMessageByChannelId(channelID, msgRequest);
		outData.status = &apos;success&apos;;
		outData.status_message = &apos;message successfully sent to channel&apos;;
	} catch (ex) {
		outData.status = &apos;error&apos;;
		outData.status_message = ex.toString();
		return outData;
	}

	if (msgResponse.getStatus() == null) {
		outData.response_status = &apos;unknown&apos;;
		logger.error(&apos;Code Template &quot;Send message to channel by id&quot;: channel &quot;&apos; + ChannelUtil.getChannelName(channelID) + &apos;&quot; does not return a valid response object&apos;);
	}
	
	switch (String(msgResponse.getStatus())) {
		case &apos;ERROR&apos;:
			outData.response_status = &apos;error&apos;;
			break;
		case &apos;FILTERED&apos;:
			outData.response_status = &apos;filtered&apos;;
			break;
		case &apos;QUEUED&apos;:
			outData.response_status = &apos;queued&apos;;
			break;
		case &apos;RECEIVED&apos;:
			outData.response_status = &apos;received&apos;;
			break;
		case &apos;SENT&apos;:
			outData.response_status = &apos;sent&apos;;
			break;
	}

	outData.response_message = msgResponse.getMessage();

	return outData;
	*/
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>f4cd9e71-4f8d-4472-80a9-31b533f4d578</id>
            <name>Get bots DB connection to specified environment</name>
            <revision>1</revision>
            <lastModified>
              <time>1636720335017</time>
              <timezone>Asia/Kolkata</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Get a new bots database connection. Be sure to wrap in try/finally block to close database connection.

	@param {String} environment - prod, staging, dev, local
	@return {String} return database connection
*/
function GetBotsDBConnection() {
	var username = configurationMap.get(&apos;bots-db-user&apos;);
	var password = configurationMap.get(&apos;bots-db-pass&apos;);
	var uri = configurationMap.get(&apos;bots-db-uri&apos;);	
	return DatabaseConnectionFactory.createDatabaseConnection(&apos;org.postgresql.Driver&apos;, uri, username, password);
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>554bd282-172b-43a0-8902-992baf63b04d</id>
            <name>Get DB connection to specified environment</name>
            <revision>1</revision>
            <lastModified>
              <time>1636720335113</time>
              <timezone>Asia/Kolkata</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Get a new database connection. 

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function GetDBConnection(environment) {
	if (environment != &apos;prod&apos; &amp;&amp; environment != &apos;staging&apos; &amp;&amp; environment != &apos;dev&apos; &amp;&amp; environment != &apos;local&apos;) {
		return null;
	}
	
	var username = configurationMap.get(&apos;docsink-db-user-&apos; + environment);
	var password = configurationMap.get(&apos;docsink-db-pass-&apos; + environment);
	var uri = configurationMap.get(&apos;docsink-db-uri-&apos; + environment);

	return DatabaseConnectionFactory.createDatabaseConnection(&apos;com.mysql.cj.jdbc.Driver&apos;, uri, username, password);
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>552a87ed-b5a0-4546-9e5c-0a768661a351</id>
            <name>Postprocessor - Generate channel response</name>
            <revision>1</revision>
            <lastModified>
              <time>1636720334961</time>
              <timezone>Asia/Kolkata</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function generateChannelResponse() {
	// This script executes once after a message has been processed
	// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
	
	var destinations = sourceMap.get(&apos;destinationSet&apos;);
	var metadataIds = destinations.toArray();
	
	if (metadataIds.length == 0) {
		return ResponseFactory.getErrorResponse(&apos;invalid request&apos;);
	}
	
	var smsg = message.getConnectorMessages().get(0);
	if (smsg.getStatus() == &apos;ERROR&apos;) {
		if (smsg.getProcessingError()) {
			return ResponseFactory.getErrorResponse(smsg.getProcessingError());
		}
		return ResponseFactory.getErrorResponse(smsg.getResponseData().getMessage());
	}
	
	var metadataID = metadataIds[0];
	var cmsg = message.getConnectorMessages().get(metadataID);

	if (cmsg.getStatus() == &apos;ERROR&apos;) {
		if (cmsg.getProcessingError()) {
			return ResponseFactory.getErrorResponse(cmsg.getProcessingError());
		}
		return ResponseFactory.getErrorResponse(cmsg.getResponseData().getMessage());
	} else if (cmsg.getStatus() == &apos;SENT&apos;) {
		return ResponseFactory.getSentResponse(cmsg.getResponseData().getMessage());
	} else if (cmsg.getStatus() == &apos;FILTERED&apos;) {
		return ResponseFactory.getFilteredResponse(cmsg.getResponseData().getMessage());
	} else if (cmsg.getStatus() == &apos;QUEUED&apos;) {
		return ResponseFactory.getQueuedResponse(cmsg.getResponseData().getMessage());
	} else if (cmsg.getStatus() == &apos;RECEIVED&apos;) {
		return ResponseFactory.getSentResponse(cmsg.getResponseData().getMessage());
	} else {
		return cmsg;
	}
}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="3.9.1">
        <id>d721d32e-8a8d-4080-aa47-b5240b04d13b</id>
        <name>Optimus Obfuscation</name>
        <revision>1</revision>
        <lastModified>
          <time>1637059908905</time>
          <timezone>Asia/Kolkata</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>false</includeNewChannels>
        <enabledChannelIds>
          <string>4bb6395a-6e04-4a81-b043-f8b6b782b413</string>
          <string>183b6833-a563-42cb-8d4d-cdcb740aef30</string>
          <string>14a2ad40-95bb-4ac9-a10e-d326537cc5a6</string>
          <string>5d5e5835-8cd3-43af-ac82-ffe57439bfb5</string>
          <string>ed3e52dc-3023-4cc7-8cad-47e0d5df89c1</string>
          <string>588338d2-d4f2-4595-b573-76834aab4f7a</string>
          <string>08955a01-dda6-468b-a8cf-73586fe7d99f</string>
          <string>e08a15ff-e999-41cf-9fc0-2147caf59114</string>
          <string>a103a9b5-d057-4f7d-b29e-324b4552685c</string>
          <string>799cb0d7-a5ff-4b3b-b039-96f15eecd7da</string>
          <string>90bc60ed-14c6-49db-b1e6-bb70d2b1d01d</string>
        </enabledChannelIds>
        <disabledChannelIds>
          <string>492a7c6c-4768-45e2-9f49-6c5488b0a2e5</string>
          <string>6aa39894-bc9b-448c-aac6-b6967a0ce243</string>
          <string>8ced4c56-22c9-4ac1-8434-3723450a7487</string>
          <string>61c7b133-bf45-4973-83a8-79406a1c6880</string>
          <string>3e15b608-553f-45e7-a617-712d6b75ab4d</string>
          <string>2f511815-92d1-4f0f-92e9-f4f8ae576b75</string>
          <string>cb7f055d-45ae-43b7-ac7c-bb2b2db34ded</string>
          <string>2b7fc97e-1f23-4792-96fc-941ec94e463b</string>
          <string>6ff8ca2b-c4e3-4e6f-897a-17f36ed63faa</string>
          <string>93ae85f8-9fd8-4391-8b87-669cc1db30da</string>
          <string>3f433a3e-e46d-440a-82c1-5490ada6b54e</string>
          <string>27aee1c0-8ed0-4062-89b5-1c7a69a946bc</string>
          <string>03770984-f6ee-4df9-be10-53bc53ca6939</string>
          <string>0763b542-8ed8-4a30-9c35-de3dbf030626</string>
          <string>ae504043-55f5-497e-ac87-33686e7569b2</string>
          <string>9d1c136c-3c94-43c3-b0f8-1c1551ac6987</string>
          <string>b2fdd8c2-f387-493b-ab35-e7e9e8ce056a</string>
          <string>930a4c9e-b458-4edf-92ff-3be07d68c28d</string>
          <string>9bb89069-137a-4e11-8beb-ea4d2d0a07d1</string>
          <string>69f5ad2c-3bf4-4d55-8e4a-bd6faade202d</string>
          <string>b255b810-ca09-42e9-a012-dd173bcb1275</string>
          <string>93f8d262-b170-4b2f-842c-e43c31a5cdbe</string>
          <string>3d95de17-a2ea-446c-be4c-36c32d8cda1c</string>
          <string>4c694f20-3ae0-4fc2-90a4-9cf5608ae666</string>
          <string>fdcb1121-0d49-4ed8-b1a1-4f4482e1c20a</string>
          <string>4deb3e09-2a2b-416d-b5fc-d207c7a3b8dd</string>
          <string>143b10e0-e01b-4942-9995-2d3b9a165d76</string>
          <string>a6825055-e697-487f-9add-560ad9567a60</string>
          <string>6060b76d-07c2-4f9f-bc71-d2e8c44d8271</string>
          <string>bd270438-7262-47f8-8656-1baf51287078</string>
          <string>61b10ef9-baef-45e2-b747-a0987d851033</string>
          <string>b5f913b9-b482-44eb-8b57-4b732b75bdc5</string>
          <string>13738349-4cc4-43de-9365-a27ead17b524</string>
          <string>bd81709b-2ef0-4760-aba9-f455fb338f37</string>
          <string>695c7ed6-252e-4229-83db-5571946a8b62</string>
          <string>50dcf6de-46b4-4de5-99c2-d341abb8a41a</string>
          <string>ed4ef090-3f7e-442d-ad30-744e3a1313f2</string>
          <string>facba601-06d7-48c7-950b-3e7a1449d694</string>
          <string>b5b06a51-3393-4c42-ab12-1680c1f43e46</string>
          <string>e1900e14-c2a2-426e-86f0-971353d60cdd</string>
          <string>a09b1b75-8f58-484d-9929-07366fd4107d</string>
          <string>99066deb-0d43-44f6-8823-b8cfe08e7185</string>
          <string>aa30f2b5-64cf-4396-b098-efeecb2224f2</string>
          <string>7445aaa5-ff13-4c08-a8b1-817cfed2692b</string>
          <string>b6642743-9801-4d4e-a46e-56676d55d986</string>
          <string>9fee4e0a-7a6d-4925-bc78-59df2c1f28af</string>
          <string>6507f618-385f-4188-9267-e084e963c471</string>
          <string>57953b24-64cb-489d-9706-bf5dc1ef94ea</string>
          <string>8e385cc0-e90d-4e37-b827-71deea5d9f0b</string>
          <string>21a820f0-205a-4046-8c4a-3788daca4d05</string>
          <string>ed628811-1214-4795-9e48-3b685ee83d3a</string>
          <string>f1f47cb7-86d5-4359-b710-97d1eb3dc644</string>
          <string>ae961745-fe19-46bd-b240-c82888091366</string>
          <string>8b61cf50-9d95-43dd-b6ab-474e2a1d2d76</string>
          <string>68581957-7fba-421f-b063-941a804fcc46</string>
          <string>4041500f-7768-4011-b273-13fe61a2ebd6</string>
          <string>d448196a-4282-4d10-8c9a-7f1dfd19abea</string>
          <string>982b29a5-1743-4435-8842-9810e4e34926</string>
          <string>f836f593-4c61-49bd-be13-4cb3f9c6cffb</string>
          <string>0fec52ca-be59-47c9-85b1-700dc3b3dc2e</string>
          <string>4f9c9e0d-7180-42c4-ab90-15ee6653c76e</string>
          <string>8c637e01-95b0-4b11-a28f-4518b7f8d1ae</string>
        </disabledChannelIds>
        <codeTemplates>
          <codeTemplate version="3.9.1">
            <id>a2df24ff-3734-4183-a331-58a805c801a7</id>
            <name>Decode</name>
            <revision>1</revision>
            <lastModified>
              <time>1637059908919</time>
              <timezone>Asia/Kolkata</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function optimus_decode(environment, value) {
	if (environment != &apos;prod&apos; &amp;&amp; environment != &apos;staging&apos; &amp;&amp; environment != &apos;dev&apos;) {
		return null;
	}
	
	var prime = configurationMap.get(&apos;docsink-&apos; + environment + &apos;-optimus-prime&apos;);
	var inverse = configurationMap.get(&apos;docsink-&apos; + environment + &apos;-optimus-inverse&apos;);
	var random = configurationMap.get(&apos;docsink-&apos; + environment + &apos;-optimus-random&apos;);

	if (!prime) {
		return null;
	}
	if (!inverse) {
		return null;
	}
	if (!random) {
		return null;
	}

	try {
		var optimus = new Optimus(prime, inverse, random);
		return optimus.decode(value);
	} catch (ex) {
		logger.error(ex);
		return null;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>7ab8dcd8-6441-46e4-815c-5268347d9f25</id>
            <name>Encode</name>
            <revision>1</revision>
            <lastModified>
              <time>1637059909081</time>
              <timezone>Asia/Kolkata</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function optimus_encode(environment, value) {
	if (environment != &apos;prod&apos; &amp;&amp; environment != &apos;staging&apos; &amp;&amp; environment != &apos;dev&apos;) {
		return null;
	}
	
	var prime = configurationMap.get(&apos;docsink-&apos; + environment + &apos;-optimus-prime&apos;);
	var inverse = configurationMap.get(&apos;docsink-&apos; + environment + &apos;-optimus-inverse&apos;);
	var random = configurationMap.get(&apos;docsink-&apos; + environment + &apos;-optimus-random&apos;);

	if (!prime) {
		return null;
	}
	if (!inverse) {
		return null;
	}
	if (!random) {
		return null;
	}

	try {
		var optimus = new Optimus(prime, inverse, random);
		return optimus.encode(value);
	} catch (ex) {
		logger.error(ex);
		return null;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>8cca9640-5085-487b-807d-8f99aec678b0</id>
            <name>Long</name>
            <revision>1</revision>
            <lastModified>
              <time>1637059908998</time>
              <timezone>Asia/Kolkata</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>COMPILED_CODE</type>
              <code>/**
 * Source: https://github.com/dcodeIO/long.js
 *
 * Constructs a 64 bit two&apos;s-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two&apos;s-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript&apos;s floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, &quot;__isLong__&quot;, { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj &amp;&amp; obj[&quot;__isLong__&quot;]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value &gt;&gt;&gt;= 0;
        if (cache = (0 &lt;= value &amp;&amp; value &lt; 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) &lt; 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 &lt;= value &amp;&amp; value &lt; 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value &lt; 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value &lt; 0)
            return UZERO;
        if (value &gt;= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value &lt;= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 &gt;= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value &lt; 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error(&apos;empty string&apos;);
    if (str === &quot;NaN&quot; || str === &quot;Infinity&quot; || str === &quot;+Infinity&quot; || str === &quot;-Infinity&quot;)
        return ZERO;
    if (typeof unsigned === &apos;number&apos;) {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix &lt; 2 || 36 &lt; radix)
        throw RangeError(&apos;radix&apos;);

    var p;
    if ((p = str.indexOf(&apos;-&apos;)) &gt; 0)
        throw Error(&apos;interior hyphen&apos;);
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i &lt; str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size &lt; 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === &apos;number&apos;)
        return fromNumber(val, unsigned);
    if (typeof val === &apos;string&apos;)
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === &apos;boolean&apos; ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 &lt;&lt; 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 &lt;&lt; 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low &gt;&gt;&gt; 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high &gt;&gt;&gt; 0) * TWO_PWR_32_DBL) + (this.low &gt;&gt;&gt; 0);
    return this.high * TWO_PWR_32_DBL + (this.low &gt;&gt;&gt; 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @this {!Long}
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix &lt; 2 || 36 &lt; radix)
        throw RangeError(&apos;radix&apos;);
    if (this.isZero())
        return &apos;0&apos;;
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return &apos;-&apos; + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = &apos;&apos;;
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() &gt;&gt;&gt; 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length &lt; 6)
                digits = &apos;0&apos; + digits;
            result = &apos;&apos; + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high &gt;&gt;&gt; 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low &gt;&gt;&gt; 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit &gt; 0; bit--)
        if ((val &amp; (1 &lt;&lt; bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long&apos;s value equals zero.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 &amp;&amp; this.low === 0;
};

/**
 * Tests if this Long&apos;s value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long&apos;s value is negative.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned &amp;&amp; this.high &lt; 0;
};

/**
 * Tests if this Long&apos;s value is positive.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high &gt;= 0;
};

/**
 * Tests if this Long&apos;s value is odd.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low &amp; 1) === 1;
};

/**
 * Tests if this Long&apos;s value is even.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low &amp; 1) === 0;
};

/**
 * Tests if this Long&apos;s value equals the specified&apos;s.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned &amp;&amp; (this.high &gt;&gt;&gt; 31) === 1 &amp;&amp; (other.high &gt;&gt;&gt; 31) === 1)
        return false;
    return this.high === other.high &amp;&amp; this.low === other.low;
};

/**
 * Tests if this Long&apos;s value equals the specified&apos;s. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long&apos;s value differs from the specified&apos;s.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long&apos;s value differs from the specified&apos;s. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long&apos;s value differs from the specified&apos;s. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long&apos;s value is less than the specified&apos;s.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) &lt; 0;
};

/**
 * Tests if this Long&apos;s value is less than the specified&apos;s. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long&apos;s value is less than or equal the specified&apos;s.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) &lt;= 0;
};

/**
 * Tests if this Long&apos;s value is less than or equal the specified&apos;s. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long&apos;s value is less than or equal the specified&apos;s. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long&apos;s value is greater than the specified&apos;s.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) &gt; 0;
};

/**
 * Tests if this Long&apos;s value is greater than the specified&apos;s. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long&apos;s value is greater than or equal the specified&apos;s.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) &gt;= 0;
};

/**
 * Tests if this Long&apos;s value is greater than or equal the specified&apos;s. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long&apos;s value is greater than or equal the specified&apos;s. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long&apos;s value with the specified&apos;s.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg &amp;&amp; !otherNeg)
        return -1;
    if (!thisNeg &amp;&amp; otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high &gt;&gt;&gt; 0) &gt; (this.high &gt;&gt;&gt; 0) || (other.high === this.high &amp;&amp; (other.low &gt;&gt;&gt; 0) &gt; (this.low &gt;&gt;&gt; 0)) ? -1 : 1;
};

/**
 * Compares this Long&apos;s value with the specified&apos;s. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long&apos;s value.
 * @this {!Long}
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned &amp;&amp; this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long&apos;s value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high &gt;&gt;&gt; 16;
    var a32 = this.high &amp; 0xFFFF;
    var a16 = this.low &gt;&gt;&gt; 16;
    var a00 = this.low &amp; 0xFFFF;

    var b48 = addend.high &gt;&gt;&gt; 16;
    var b32 = addend.high &amp; 0xFFFF;
    var b16 = addend.low &gt;&gt;&gt; 16;
    var b00 = addend.low &amp; 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 &gt;&gt;&gt; 16;
    c00 &amp;= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c48 += a48 + b48;
    c48 &amp;= 0xFFFF;
    return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    /*
    if (wasm) {
        var low = wasm[&quot;mul&quot;](this.low,
                              this.high,
                              multiplier.low,
                              multiplier.high);
        return fromBits(low, wasm[&quot;get_high&quot;](), this.unsigned);
    }
    */

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) &amp;&amp; multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high &gt;&gt;&gt; 16;
    var a32 = this.high &amp; 0xFFFF;
    var a16 = this.low &gt;&gt;&gt; 16;
    var a00 = this.low &amp; 0xFFFF;

    var b48 = multiplier.high &gt;&gt;&gt; 16;
    var b32 = multiplier.high &amp; 0xFFFF;
    var b16 = multiplier.low &gt;&gt;&gt; 16;
    var b00 = multiplier.low &amp; 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 &gt;&gt;&gt; 16;
    c00 &amp;= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &amp;= 0xFFFF;
    return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @this {!Long}
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error(&apos;division by zero&apos;);

    // use wasm support if present
    /*
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two&apos;s complement.
        if (!this.unsigned &amp;&amp;
            this.high === -0x80000000 &amp;&amp;
            divisor.low === -1 &amp;&amp; divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm[&quot;div_u&quot;] : wasm[&quot;div_s&quot;])(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm[&quot;get_high&quot;](), this.unsigned);
    }
    */

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| &gt;= 2, so |this/other| &lt; |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It&apos;s therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 &gt;&gt;&gt; 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 &lt;= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can&apos;t be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @this {!Long}
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    /*
    if (wasm) {
        var low = (this.unsigned ? wasm[&quot;rem_u&quot;] : wasm[&quot;rem_s&quot;])(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm[&quot;get_high&quot;](), this.unsigned);
    }
    */

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @this {!Long}
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @this {!Long}
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low &amp; other.low, this.high &amp; other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @this {!Long}
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @this {!Long}
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0)
        return this;
    else if (numBits &lt; 32)
        return fromBits(this.low &lt;&lt; numBits, (this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low &lt;&lt; (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0)
        return this;
    else if (numBits &lt; 32)
        return fromBits((this.low &gt;&gt;&gt; numBits) | (this.high &lt;&lt; (32 - numBits)), this.high &gt;&gt; numBits, this.unsigned);
    else
        return fromBits(this.high &gt;&gt; (numBits - 32), this.high &gt;= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0) return this;
    if (numBits &lt; 32) return fromBits((this.low &gt;&gt;&gt; numBits) | (this.high &lt;&lt; (32 - numBits)), this.high &gt;&gt;&gt; numBits, this.unsigned);
    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high &gt;&gt;&gt; (numBits - 32), 0, this.unsigned);
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits rotated to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
    if (numBits &lt; 32) {
        b = (32 - numBits);
        return fromBits(((this.low &lt;&lt; numBits) | (this.high &gt;&gt;&gt; b)), ((this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; b)), this.unsigned);
    }
    numBits -= 32;
    b = (32 - numBits);
    return fromBits(((this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; b)), ((this.low &lt;&lt; numBits) | (this.high &gt;&gt;&gt; b)), this.unsigned);
}
/**
 * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotl = LongPrototype.rotateLeft;

/**
 * Returns this Long with bits rotated to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotateRight = function rotateRight(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
    if (numBits &lt; 32) {
        b = (32 - numBits);
        return fromBits(((this.high &lt;&lt; b) | (this.low &gt;&gt;&gt; numBits)), ((this.low &lt;&lt; b) | (this.high &gt;&gt;&gt; numBits)), this.unsigned);
    }
    numBits -= 32;
    b = (32 - numBits);
    return fromBits(((this.low &lt;&lt; b) | (this.high &gt;&gt;&gt; numBits)), ((this.high &lt;&lt; b) | (this.low &gt;&gt;&gt; numBits)), this.unsigned);
}
/**
 * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotr = LongPrototype.rotateRight;

/**
 * Converts this Long to signed.
 * @this {!Long}
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @this {!Long}
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @this {!Long}
 * @returns {!Array.&lt;number&gt;} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @this {!Long}
 * @returns {!Array.&lt;number&gt;} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        &amp; 0xff,
        lo &gt;&gt;&gt;  8 &amp; 0xff,
        lo &gt;&gt;&gt; 16 &amp; 0xff,
        lo &gt;&gt;&gt; 24       ,
        hi        &amp; 0xff,
        hi &gt;&gt;&gt;  8 &amp; 0xff,
        hi &gt;&gt;&gt; 16 &amp; 0xff,
        hi &gt;&gt;&gt; 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @this {!Long}
 * @returns {!Array.&lt;number&gt;} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi &gt;&gt;&gt; 24       ,
        hi &gt;&gt;&gt; 16 &amp; 0xff,
        hi &gt;&gt;&gt;  8 &amp; 0xff,
        hi        &amp; 0xff,
        lo &gt;&gt;&gt; 24       ,
        lo &gt;&gt;&gt; 16 &amp; 0xff,
        lo &gt;&gt;&gt;  8 &amp; 0xff,
        lo        &amp; 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.&lt;number&gt;} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.&lt;number&gt;} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] &lt;&lt;  8 |
        bytes[2] &lt;&lt; 16 |
        bytes[3] &lt;&lt; 24,
        bytes[4]       |
        bytes[5] &lt;&lt;  8 |
        bytes[6] &lt;&lt; 16 |
        bytes[7] &lt;&lt; 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.&lt;number&gt;} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] &lt;&lt; 24 |
        bytes[5] &lt;&lt; 16 |
        bytes[6] &lt;&lt;  8 |
        bytes[7],
        bytes[0] &lt;&lt; 24 |
        bytes[1] &lt;&lt; 16 |
        bytes[2] &lt;&lt;  8 |
        bytes[3],
        unsigned
    );
};</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>8c374bb2-480f-4b69-abd5-cb93f6326227</id>
            <name>Optimus</name>
            <revision>1</revision>
            <lastModified>
              <time>1637059908958</time>
              <timezone>Asia/Kolkata</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>COMPILED_CODE</type>
              <code>// Source: https://github.com/chamindu/optimus-js

var MAX_INT32 = 2147483647;
var MULTIPLIER = 4294967296 // 2^32;

var root = this;
var prevOptimus = root.Optimus;

var has_require = typeof require !== &apos;undefined&apos;
var Long;

var Optimus = function (prime, inverse, random) {
    this.prime = Long.fromInt(prime);
    this.inverse = Long.fromInt(inverse);
    this.random = Long.fromInt(random);
};

Optimus.prototype.encode = function (num) {
    var n = Long.fromInt(num);
    return n.mul(this.prime).and(Long.fromInt(MAX_INT32)).xor(this.random).toSigned().toInt();
};

Optimus.prototype.decode = function (num) {
    var n = Long.fromInt(num);
    return n.xor(this.random).mul(this.inverse).and(Long.fromInt(MAX_INT32)).toSigned().toInt();
};

Optimus.noConflict = function () {
    root.Optimus = prevOptimus;
    return Optimus;
}

if (typeof exports !== &apos;undefined&apos;) {
    if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) {
        exports = module.exports = Optimus;
    }
    exports.mymodule = Optimus;
}
else {
    root.Optimus = Optimus;
}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
    </codeTemplateLibraries>
  </exportData>
</channel>